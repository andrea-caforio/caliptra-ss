// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Use the gen-otp-mmap.py script to update dependent files (like documentation
// tables the comportable hjson and metadata SV package):
//
// $ ./util/design/gen-otp-mmap.py
//
// Make sure to regenerate the CSRs after converting the memory map:
//
// $ cd ${PROJ_ROOT}
// $ make -C hw regs
//

{
    // 256 bit seed to be used for generation of partition item default values.
    // Can be overridden on the command line with the --seed switch.
    seed: "36021179872380457113239299468132194022238108125576166239904535336103582949069"

    otp: {
        width: "2", // bytes
        depth: "1024"
    }

    // Definition of scrambling and digest constants and keys.
    scrambling: {
        key_size:  "16",
        iv_size:   "8",
        cnst_size: "16",
        keys: [
            {
                name:  "SecretManufKey",
                value: "<random>",
            },
            {
                name:  "SecretProdKey0",
                value: "<random>",
            },
            {
                name:  "SecretProdKey1",
                value: "<random>",
            },
            {
                name:  "SecretProdKey2",
                value: "<random>",
            },
            {
                name:  "SecretProdKey3",
                value: "<random>",
            },
            {
                name:  "SecretLifeCycleUnlockKey",
                value: "<random>",
            },
            {
                name:  "SecretLifeCycleManufKey",
                value: "<random>",
            },
            {
                name:  "SecretLifeCycleProdKey",
                value: "<random>",
            },
            {
                name:  "SecretLifeCycleRMAKey",
                value: "<random>",
            },
        ]
        digests: [
            // This is the consistency digest used by all partitions.
            {
                name:       "CnstyDigest",
                iv_value:   "<random>",
                cnst_value: "<random>",
            }
            /*
            // The other digest configurations below are used for
            // key derivation and token hashing.
            {
                name:       "FlashDataKey",
                iv_value:   "<random>",
                cnst_value: "<random>",
            }
            {
                name:       "FlashAddrKey",
                iv_value:   "<random>",
                cnst_value: "<random>",
            }
            {
                name:       "SramDataKey",
                iv_value:   "<random>",
                cnst_value: "<random>",
            }
            */
        ]
    }

    // The enumeration order below defines the address map of the OTP controller,
    // if the offsets are not defined explicitly via the "offset" key.
    // Note that the digest items are added automatically to the address map.
    partitions: [
        {
            name:       "SECRET_MANUF_PARTITION",
            variant:    "Buffered",
            secret:     true,
            sw_digest:  false,
            hw_digest:  true,
            write_lock: "Digest",
            read_lock:  "Digest",
            key_sel:    "SecretManufKey",
            integrity:  true,
            bkout_type: true,
            items: [
                {
                    name: "UDS_SEED",
                    inv_default: "<random>",
                    size: "64",
                    desc: '''
                    DICE Unique Device Secret Seed.
                    This seed is unique per device. The seed is scrambled using an obfuscation function.
                    '''
                },
            ],
            desc: '''Secret manufacturing partition.
            '''
        },
        {
            name:       "SECRET_PROD_PARTITION_0",
            variant:    "Buffered",
            secret:     true,
            sw_digest:  false,
            hw_digest:  true,
            write_lock: "Digest",
            read_lock:  "Digest",
            key_sel:    "SecretProdKey0",
            integrity:  true,
            bkout_type: true,
            items: [
                {
                    name: "FIELD_ENTROPY_0",
                    inv_default: "<random>",
                    size: "8",
                    desc: '''
                    Field entropy chunk 0.
                    Field-programmable by the owner, used to hedge against UDS disclosure in the supply chain.
                    '''
                },
            ],
            desc: '''Secret production partition 0.
            '''
        },
        {
            name:       "SECRET_PROD_PARTITION_1",
            variant:    "Buffered",
            secret:     true,
            sw_digest:  false,
            hw_digest:  true,
            write_lock: "Digest",
            read_lock:  "Digest",
            key_sel:    "SecretProdKey1",
            integrity:  true,
            bkout_type: true,
            items: [
                {
                    name: "FIELD_ENTROPY_1",
                    inv_default: "<random>",
                    size: "8",
                    desc: '''
                    Field entropy chunk 1.
                    Field-programmable by the owner, used to hedge against UDS disclosure in the supply chain.
                    '''
                },
            ],
            desc: '''Secret production partition 1.
            '''
        },
        {
            name:       "SECRET_PROD_PARTITION_2",
            variant:    "Buffered",
            secret:     true,
            sw_digest:  false,
            hw_digest:  true,
            write_lock: "Digest",
            read_lock:  "Digest",
            key_sel:    "SecretProdKey2",
            integrity:  true,
            bkout_type: true,
            items: [
                {
                    name: "FIELD_ENTROPY_2",
                    inv_default: "<random>",
                    size: "8",
                    desc: '''
                    Field entropy chunk 2.
                    Field-programmable by the owner, used to hedge against UDS disclosure in the supply chain.
                    '''
                },
            ],
            desc: '''Secret production partition 2.
            '''
        },
        {
            name:       "SECRET_PROD_PARTITION_3",
            variant:    "Buffered",
            secret:     true,
            sw_digest:  false,
            hw_digest:  true,
            write_lock: "Digest",
            read_lock:  "Digest",
            key_sel:    "SecretProdKey3",
            integrity:  true,
            bkout_type: true,
            items: [
                {
                    name: "FIELD_ENTROPY_3",
                    inv_default: "<random>",
                    size: "8",
                    desc: '''
                    Field entropy chunk 3.
                    Field-programmable by the owner, used to hedge against UDS disclosure in the supply chain.
                    '''
                },
            ],
            desc: '''Secret production partition 3.
            '''
        },
        {
            name:       "SW_MANUF_PARTITION",
            variant:    "Unbuffered",
            absorb:     true,
            secret:     false,
            sw_digest:  true,
            hw_digest:  false,
            write_lock: "Digest",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            integrity:  true,
            bkout_type: false,
            items: [
                {
                    name: "KEY_MANIFEST_PK_HASH",
                    size: "48"
                },
                {
                    name: "ANTI_ROLLBACK_DISABLE",
                    size: "1",
                    desc: '''
                    Disables anti-rollback support from Caliptra.
                    For example, if a Platform RoT is managing FW storage and anti-rollback protection external to the SoC.
                    '''
                },
                {
                    name: "IDEVID_CERT_IDEVID_ATTR",
                    size: "96",
                    desc: '''
                    IDevID Certificate Generation Attributes.
                    See IDevID certificate section. Caliptra only uses 352 bits. Integrator is not required
                    to back the remaining 416 bits with physical fuses.
                    '''
                },
                {
                    name: "IDEVID_MANUF_HSM_IDENTIFIER",
                    size: "16",
                    desc: '''
                    Spare bits for Vendor IDevID provisioner CA identifiers.
                    Caliptra does not use these bits. Integrator is not required to back these with physical fuses.
                    '''
                },
                {
                    name: "SOC_STEPPING_ID",
                    size: "2",
                    desc: '''
                    Identifier assigned by vendor to differentiate silicon steppings.
                    '''
                },
                {
                    name: "MANUF_DEBUG_UNLOCK_TOKEN",
                    size: "16",
                    desc: '''
                    Secret value for manufacturing debug unlock authorization.
                    '''
                },
                {
                    name: "PROD_DEBUG_UNLOCK_PKS",
                    size: "512",
                    desc: '''
                    There are 8 different debug levels in production state.
                    Thus, we need one 512-bit location for hash of each of public keys.
                    '''
                },
                {
                    name: "VENDOR_EXPANDED_CALIPTRA_FW_AUTH_PK_HASHES",
                    size: "48",
                    desc: '''
                    N is configurable from 0 (as not having this configuration) to up to 16.
                    '''
                },
                {
                    name: "VENDOR_SPECIFIC_SECRET_FUSES",
                    size: "32"
                },
            ],
            desc: '''Software manufacturing partition.
            '''
        },
        {
            name:       "SW_PROD_PARTITION",
            variant:    "Unbuffered",
            absorb:     true,
            secret:     false,
            sw_digest:  true,
            hw_digest:  false,
            write_lock: "Digest",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            integrity:  true,
            bkout_type: false,
            items: [
                {
                    name:   "ECC_REVOCATION",
                    size:   "1",
                    desc: '''
                    One-hot encoded list of revoked Vendor ECDSA P384 Public Keys (up to 4 keys).
                    '''
                },
                {
                    name:   "OWNER_PK_HASH",
                    size:   "48",
                    desc: '''
                    SHA384 hash of the Owner ECDSA P384 and LMS or MLDSA Public Keys.
                    '''
                },
                {
                    name:   "LMS_REVOCATION",
                    size:   "4",
                    desc: '''
                    One-hot encoded list of revoked Vendor LMS Public Keys (up to 32 keys).
                    '''
                },
                {
                    name:   "MLDSA_REVOCATION",
                    size:   "4",
                    desc: '''
                    One-hot encoded list of revoked Vendor MLDSA Public Keys (up to 4 keys).
                    '''
                },
                {
                    name:   "VENDOR_EXPANDED_CALIPTRA_FW_AUTH_PK_HASH_VALID",
                    size:   "1",
                    desc: '''
                    Once a key is marked valid, anything above should not be able to be written (essentially
                    a volatile lock should be implemented on higher order bits).
                    '''
                },
            ],
            desc: '''Software production partition.
            '''
        },
        {
            name:       "SECRET_LC_UNLOCK_PARTITION",
            variant:    "Buffered",
            secret:     true,
            sw_digest:  false,
            hw_digest:  true,
            write_lock: "Digest",
            read_lock:  "Digest",
            key_sel:    "SecretLifeCycleUnlockKey",
            integrity:  true,
            bkout_type: false,
            items: [
                {
                    name: "TEST_UNLOCK_TOKEN_0",
                    inv_default: "<random>",
                    size: "16"
                },
                {
                    name: "TEST_UNLOCK_TOKEN_1",
                    inv_default: "<random>",
                    size: "16"
                },
                {
                    name: "TEST_UNLOCK_TOKEN_2",
                    inv_default: "<random>",
                    size: "16"
                },
                {
                    name: "TEST_UNLOCK_TOKEN_3",
                    inv_default: "<random>",
                    size: "16"
                },
                {
                    name: "TEST_UNLOCK_TOKEN_4",
                    inv_default: "<random>",
                    size: "16"
                },
                {
                    name: "TEST_UNLOCK_TOKEN_5",
                    inv_default: "<random>",
                    size: "16"
                },
                {
                    name: "TEST_UNLOCK_TOKEN_6",
                    inv_default: "<random>",
                    size: "16"
                },
                {
                    name: "TEST_UNLOCK_TOKEN_7",
                    inv_default: "<random>",
                    size: "16"
                },
            ],
            desc: '''Secret life-cycle unlock token partition.
            '''
        },
        {
            name:       "SECRET_LC_MANUF_PARTITION",
            variant:    "Buffered",
            secret:     true,
            sw_digest:  false,
            hw_digest:  true,
            write_lock: "Digest",
            read_lock:  "Digest",
            key_sel:    "SecretLifeCycleManufKey",
            integrity:  true,
            bkout_type: false,
            items: [
                {
                    name: "MANUF_TOKEN",
                    inv_default: "<random>",
                    size: "16",
                    desc: '''
                    Used to transition the device from TEST_UNLOCKED to MANUF state. 128-bit is
                    the token and 64 bit is the digest of the token.
                    '''
                },
            ],
            desc: '''Secret life-cycle manufacturing token partition.
            '''
        },
        {
            name:       "SECRET_LC_PROD_PARTITION",
            variant:    "Buffered",
            secret:     true,
            sw_digest:  false,
            hw_digest:  true,
            write_lock: "Digest",
            read_lock:  "Digest",
            key_sel:    "SecretLifeCycleProdKey",
            integrity:  true,
            bkout_type: false,
            items: [
                {
                    name: "PROD_TOKEN",
                    inv_default: "<random>",
                    size: "16",
                    desc: '''
                    Used to transition the device from MANUF to PROD state. 128-bit is the token and 64 bit is the digest of the token.
                    '''
                },
            ],
            desc: '''Secret life-cycle production token partition.
            '''
        },
        {
            name:       "SECRET_LC_RMA_PARTITION",
            variant:    "Buffered",
            secret:     true,
            sw_digest:  false,
            hw_digest:  true,
            write_lock: "Digest",
            read_lock:  "Digest",
            key_sel:    "SecretLifeCycleRMAKey",
            integrity:  true,
            bkout_type: false,
            items: [
                {
                    name: "RMA_TOKEN",
                    inv_default: "<random>",
                    size: "16",
                    desc: '''
                    Used to transition the device to RMA state. 128-bit is the token and 64 bit is the digest of the token.
                    '''
                },
            ],
            desc: '''Secret life-cycle RMA token partition.
            '''
        },
        {
            name:       "SVN_PARTITION",
            variant:    "Unbuffered",
            absorb:     false,
            secret:     false,
            sw_digest:  false,
            hw_digest:  false,
            write_lock: "None",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            // This is a strike counter, hence we need to disable ECC integrity for this to work.
            // Integrity is handled at a higher level by SW as described below.
            integrity:  false,
            bkout_type: false,
            items: [
                {
                    name: "FMC_KEY_MANIFEST_SVN",
                    size: "4",
                    desc: '''
                    FMC security version number.
                    '''
                },
                {
                    name: "RUNTIME_SVN",
                    size: "16",
                    desc: '''
                    Runtime firmware security version number.
                    '''
                },
            ],
            desc: '''SVN Partition.
            '''
        },
        {
            name:       "VENDOR_TEST_PARTITION",
            variant:    "Unbuffered",
            size:       "64", // in bytes
            secret:     false,
            sw_digest:  true,
            hw_digest:  false,
            write_lock: "Digest",
            read_lock:  "CSR",
            key_sel:    "NoKey",
            integrity:  false, // Do not use integrity (ECC) on this partition.
            bkout_type: false, // Do not generate a breakout type for this partition.
            items: [
                {
                    name: "VENDOR_TEST",
                    size: "32",
                    desc: '''
                    This is a partition used to test if FUSE programming is done accordingly.
                    It has 14 32-bit vendor test write location and one 64-bit for their digest values.
                    '''
                }
            ],
            desc: '''Vendor test partition.
            '''
        },
        {
            name:       "LIFE_CYCLE",
            variant:    "LifeCycle",
            secret:     false,
            sw_digest:  false,
            hw_digest:  false,
            write_lock: "None",
            read_lock:  "None",
            key_sel:    "NoKey",
            integrity:  true,
            bkout_type: false,
            items: [
                // The life cycle transition count is specified
                // first such that any programming attempt of the life cycle
                // partition through the LCI will always write the transition
                // counter words first when programming an updated state vector.
                // This is an additional safeguard, to the sequencing in the
                // life cycle controller to ensure that the counter is always written
                // before any state update. I.e., the life cycle controller
                // already splits the counter and state updates into two
                // supsequent requests through the LCI, where the first request
                // only contains the updated transition counter, and the second
                // request the updated transition counter and state.
                {
                    name: "LC_TRANSITION_CNT",
                    inv_default: "<random>",
                    size: "48"
                }
                {
                    name: "LC_STATE",
                    inv_default: "<random>",
                    size: "40"
                }
            ],
            desc: '''Lifecycle partition.
            This contains lifecycle transition count and state. This partition
            cannot be locked since the life cycle state needs to advance to RMA
            in-field. Note that while this partition is not marked secret, it
            is not readable nor writeable via the DAI. Only the LC controller
            can access this partition, and even via the LC controller it is not
            possible to read the raw manufacturing life cycle state in encoded
            form, since that encoding is considered a netlist secret. The LC
            controller only exposes a decoded version of this state.
            '''
        },
    ]
}